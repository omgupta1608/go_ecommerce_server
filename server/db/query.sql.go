// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: query.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
  user_id, status
) VALUES (
  $1, $2
)
RETURNING id, user_id, status, created_at, updated_at, deleted_at
`

type CreateOrderParams struct {
	UserID uuid.UUID
	Status string
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder, arg.UserID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createOrderProduct = `-- name: CreateOrderProduct :one
INSERT INTO order_products (
  order_id, product_id, quantity, placed
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, order_id, product_id, quantity, created_at, updated_at, deleted_at, placed
`

type CreateOrderProductParams struct {
	OrderID   uuid.UUID
	ProductID uuid.UUID
	Quantity  int32
	Placed    bool
}

func (q *Queries) CreateOrderProduct(ctx context.Context, arg CreateOrderProductParams) (OrderProduct, error) {
	row := q.db.QueryRowContext(ctx, createOrderProduct,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.Placed,
	)
	var i OrderProduct
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Placed,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
  name, price, in_stock
) VALUES (
  $1, $2, $3
)
RETURNING id, name, price, in_stock, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	Name    string
	Price   float64
	InStock int32
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct, arg.Name, arg.Price, arg.InStock)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.InStock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProductRating = `-- name: CreateProductRating :one
INSERT INTO ratings (
  user_id, product_id, rating
) VALUES (
  $1, $2, $3
)
RETURNING id, product_id, user_id, rating, created_at, updated_at, deleted_at
`

type CreateProductRatingParams struct {
	UserID    uuid.UUID
	ProductID uuid.UUID
	Rating    int32
}

func (q *Queries) CreateProductRating(ctx context.Context, arg CreateProductRatingParams) (Rating, error) {
	row := q.db.QueryRowContext(ctx, createProductRating, arg.UserID, arg.ProductID, arg.Rating)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  name, email, password
) VALUES (
  $1, $2, $3
)
RETURNING id, name, email, password, created_at, deleted_at, updated_at
`

type CreateUserParams struct {
	Name     string
	Email    string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Name, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFailedOrderProducts = `-- name: GetFailedOrderProducts :many
SELECT id, order_id, product_id, quantity, created_at, updated_at, deleted_at, placed from order_products
WHERE placed = false
`

func (q *Queries) GetFailedOrderProducts(ctx context.Context) ([]OrderProduct, error) {
	rows, err := q.db.QueryContext(ctx, getFailedOrderProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderProduct
	for rows.Next() {
		var i OrderProduct
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Placed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderById = `-- name: GetOrderById :one
SELECT id, user_id, status, created_at, updated_at, deleted_at FROM orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrderById(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderById, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrderDetails = `-- name: GetOrderDetails :many
select o.id as order_id, o.status, p.id as product_id, p.name, op.quantity, p.price, op.placed, u.name as user_name, u.email from orders as o 
join (order_products as op join products as p on op.product_id = p.id)
on op.order_id = o.id
join users as u on o.user_id = u.id
where o.id = $1
`

type GetOrderDetailsRow struct {
	OrderID   uuid.UUID
	Status    string
	ProductID uuid.UUID
	Name      string
	Quantity  int32
	Price     float64
	Placed    bool
	UserName  string
	Email     string
}

func (q *Queries) GetOrderDetails(ctx context.Context, id uuid.UUID) ([]GetOrderDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderDetails, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderDetailsRow
	for rows.Next() {
		var i GetOrderDetailsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.Status,
			&i.ProductID,
			&i.Name,
			&i.Quantity,
			&i.Price,
			&i.Placed,
			&i.UserName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductById = `-- name: GetProductById :one
SELECT id, name, price, in_stock, created_at, updated_at, deleted_at FROM products
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProductById(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductById, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.InStock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTop3Customers = `-- name: GetTop3Customers :many
select u.id, u.name as user_name, count(*) as orders_placed from orders as o 
join users as u on o.user_id = u.id 
group by u.id 
order by orders_placed desc
limit 3
`

type GetTop3CustomersRow struct {
	ID           uuid.UUID
	UserName     string
	OrdersPlaced int64
}

func (q *Queries) GetTop3Customers(ctx context.Context) ([]GetTop3CustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTop3Customers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTop3CustomersRow
	for rows.Next() {
		var i GetTop3CustomersRow
		if err := rows.Scan(&i.ID, &i.UserName, &i.OrdersPlaced); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password, created_at, deleted_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, name, email, password, created_at, deleted_at, updated_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listProductsWithRatings = `-- name: ListProductsWithRatings :many
select p.id, p.name, CAST(AVG(r.rating) AS DECIMAL(10,2)) as avg_rating, count(*) as rating_count from products as p inner join ratings as r on r.product_id = p.id group by p.id
`

type ListProductsWithRatingsRow struct {
	ID          uuid.UUID
	Name        string
	AvgRating   string
	RatingCount int64
}

func (q *Queries) ListProductsWithRatings(ctx context.Context) ([]ListProductsWithRatingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsWithRatings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsWithRatingsRow
	for rows.Next() {
		var i ListProductsWithRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AvgRating,
			&i.RatingCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderProductStatus = `-- name: UpdateOrderProductStatus :one
UPDATE order_products SET placed = $1 WHERE id = $2 RETURNING id, order_id, product_id, quantity, created_at, updated_at, deleted_at, placed
`

type UpdateOrderProductStatusParams struct {
	Placed bool
	ID     uuid.UUID
}

func (q *Queries) UpdateOrderProductStatus(ctx context.Context, arg UpdateOrderProductStatusParams) (OrderProduct, error) {
	row := q.db.QueryRowContext(ctx, updateOrderProductStatus, arg.Placed, arg.ID)
	var i OrderProduct
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Placed,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders SET status = $1 WHERE id = $2 RETURNING id, user_id, status, created_at, updated_at, deleted_at
`

type UpdateOrderStatusParams struct {
	Status string
	ID     uuid.UUID
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrderStatus, arg.Status, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductInStockUnits = `-- name: UpdateProductInStockUnits :one
UPDATE products SET in_stock = $1 WHERE id = $2 RETURNING id, name, price, in_stock, created_at, updated_at, deleted_at
`

type UpdateProductInStockUnitsParams struct {
	InStock int32
	ID      uuid.UUID
}

func (q *Queries) UpdateProductInStockUnits(ctx context.Context, arg UpdateProductInStockUnitsParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProductInStockUnits, arg.InStock, arg.ID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.InStock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
